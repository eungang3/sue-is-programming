---
layout: post
title:  "Javascript forkify 따라하기"
date:   2020-07-08 00:10:27 +0900
categories: Javascript
---

Udemy - [The Complete JavaScript Course 2020: Build Real Projects!](https://www.udemy.com/course/the-complete-javascript-course/) 강좌의 섹션 9. Modern JavaScript: Using ES6, NPM, Babel and Webpack을 요약한 내용입니다.

## 0. Modern Javascript
- 요즘은 과거와 달리 다양한 툴과 함께 javascript 사용함. Node js와 NPM ecosystem 기반.

### 1) NPM 
- Node Package Manager. 개발에 필요한 각종 라이브러리(예: Lodash, Jquery), 프레임워크(예: React, Angular), 툴(예: Babel, webpack)을 설치하고 관리하는 command line interface 

- package.json : 프로젝트에 대한 정보 담고있는 파일. 공동작업할 때 프로젝트의 package.json 파일을 NPM으로 읽고 필요한 dependency 설치하는 식으로 사용. 
    + npmm install dependencyName --save-dev 커맨드로 설치한 dependency는 해당 프로젝트에서만 사용 가능
    + 같은 컴퓨터의 다른 프로젝트에서도 사용하고 싶다면 sudo npm install dependencyName --global 커맨드로 설치. 
    + scripts에 "dev" : "webpack" 쓰고 저장하면, 터미널에서 npm run dev 입력했을 때 webpack config.js파일 찾아서 적힌대로 webpack 실행.

<br/>

### 2) Webpack 
- 아직 브라우저에서 ES6 모듈 지원 안됨 -> webpack이 모듈 모아서 module bundler라는 하나의 파일로 만들어줌. 모듈뿐만 아니라 이미지 파일, css 등도 bundle로 만들 수 있음.

- configuration: 환경설정. 간단한 static website는 configuration할 필요 없음.
    + entry point : webpack이 bundling 시작하는 곳. bundle로 만들어야 할 dependencies 찾는 곳. 
    + output : bundle 저장할 곳. path, filename property 갖는 object로 작성. path는 absolute path라야 함. filename은 보통 bundle.js
    + loaders : 파일 로드하고 process함. (예: SASS를 CSS 코드로 변환, ES6 코드를 ES5 코드로 변환)
    + plugins : 사용할 플러그인을 모두 한 array 안에 넣음. (예: src 폴더에 있는 html 파일을 dist 폴더에 있는 html 파일로 inject해서 webpack dev server에서 livestream해주는 HtmlWebpackPlugin)
    + mode : development(최적화 하지 않고 bundler 만드는 모드), production(minification, tree shaking 등 최적화 진행하는 모드)

- webpack cli : webpack command line interface

- webpack dev server: 코드 저장할 때마다 자동으로 웹페이지 리로드해주는 프로그램. 

{% highlight javascript %}
// path는 built in Node package
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    entry: ['babel-polyfill', './src/js/index.js'],
    output: {
        // __dirname은 현재 위치의 absolute path, disst/js는 bundle을 저장할 곳
        path: path.resolve(__dirname, 'dist'),
        filename: 'js/bundle.js'
    },
    devServer: {
        contentBase: './dist'
    },
    plugins: [
        new HtmlWebpackPlugin({
            filename: 'index.html',
            template: './src/index.html'
        })
    ],
    module: {
        rules: [
            {
                // .js로 끝나는 모든 파일에 적용
                test: /\.js$/,
                // node_module에 있는 파일은 제외
                exclude: /node_modules/,
                use: {
                    // babel을 이용해서 로드
                    loader: 'babel-loader'
                }
            }
        ]
    }
    mode: 'development'

}
{% endhighlight %}  

<br/>

### 3) Babel 
- Babel : ES6 이상 버전 syntax로 작성된 코드를 ES5 버전 코드로 transpile
- webpack loader로 지정해서 사용.
- config 파일 작성 필요.
- Babel-polyfill:
    + ES5에 존재하지 않는 기능이라 transpile이 불가능한 ES6 코드(예: promise, array.form)를 ES5에서 동작하게 바꿔주는 라이브러리.
    + dev-dependency가 아니고 dependency에 들어감 

{% highlight javascript %}
// 파일명 .babelrc 
{
    // preset은 코드를 변형하는 용도의 플러그인 모음 
    "presets": [
        // dev-dependency인 babel-preset-env를 말함. 
        ["env", {
            "targets": [
                // 최근 브라우저 버전 5개에서 작동할 수 있게 ES6 코드 바꿔줌.
                "last 5 versions",
                "ie >= 8"
            ]
        }]
    ]
}
{% endhighlight %}  

<br/>

### 4) Axios
- HTTP request 라이브러리. fetch()와 비슷한 기능
- 브라우저에서 지원하는 기능인 fetch() api는 구버전 브라우저에서 안되는 경우 있기 때문에 axios 사용
- 모든 브라우저에서 작동, fetch()와 다르게 자동으로 json 파일 반환
- 'npm install axios'로 설치

<br/>

### cf. Command Line
- ls, cd, pwd
- cd .. : 한 칸 위로
- 파일명 입력하다가 탭 누르면 자동 완성
- mkdir : 폴더 만들기
- touch : 파일 만들기
- cp : 복사 (cp 파일명 폴더명 / 부모 폴더로 복사 예: cp index.html ..)
- mv : 이동 (mv 파일명 폴더명 / 부모 폴더로 이동 예: mv index.html ..)
- rm : 삭제 (rm 파일명). 휴지통으로 안가고 영영 삭제됨
- rm -r : 폴더와 내용물 삭제 (rm -r 폴더명). r은 recursively를 뜻함
- open : 파일 열기 (open 파일명)

<br/>

## 1. MVC model
- model, controller, view를 분리하는 것
- model은 프로그램의 로직, view는 UI, controller는 model과 view를 연결.
- model의 파일명은 대문자로 시작하는 convention 있음.

<br/>

## 2. ES6 모듈
### 1) default export
{% highlight javascript %}
export default 'I am gonna be exported.';
{% endhighlight %}  

{% highlight javascript %}
// 모듈 import할 때는 파일명의 .js 생략 
import string from './models/Search'
{% endhighlight %}  

<br/>

### 2) named export
- 여러개 export할 때 사용

{% highlight javascript %}
export const sum = (x, y) => x + y;
export const multiply = (x, y) => x * y;
export const num = 1;
{% endhighlight %}  

{% highlight javascript %}
// as 사용해서 다른 이름 지정 가능
import { sum, multiply as m, num } from './views/searchView'
console.log(sum(num, 2)); // 3
console.log(m(1, 2);) // 2
{% endhighlight %}  

{% highlight javascript %}
// 전부 import하기 
import * as calc from './views/searchView';
console.log(calc.sum(calc.num, 2)); // 3
{% endhighlight %}  

<br/>

## 3. API 사용하기
- api key : 각 유저에게 부여되는 id 같은 것. 유저가 하루에 몇 개 request 했는지 체크(가입한 플랜에서 제공하는 개수 넘어가면 요청 못하게 막는 역할.) 

{% highlight javascript %}
// axios를 사용할 js 파일에 import 해야함.
// 외부 소스로 설치한 npm 모듈 import할 때는 전체 경로 쓸 필요 없이 패키지 이름만 작성
import axios from 'axios'

async function getRes(query){
    const result = await axios(`https://forkify-api.herokuapp.com/api/search?q=${query}`);
    try {
        const recipes = result.data.recipes;
        console.log(recipes);
    } catch (error) {
        alert(error);
    }
    
}

getRes('green pepper');
{% endhighlight %}  

<br/>

## 4. 기타

- reduce() : array에 사용가능한 method
{% highlight javascript %}

{% endhighlight %}
---
layout: post
title:  " SQL, model, migration"
date:   2021-03-05 07:16:27 +0900
categories: HTTP
---

## 0. SQL, Model, Migration
- SQL : 데이터베이스를 조작하는 언어.
- Model : 데이터베이스의 스키마를 정의하는 Django 클래스.  
- Migration : Model을 바탕으로 SQL query를 생성하여 데이터베이스의 스키마를 업데이트하는 것.

<br/>

## 1. SQLite
- Django의 디폴트 database management system. 용량 가벼운 편.
- SQLite 설치 -> 터미널에서 "touch employees.sql"로 파일 만들기 -> sqlite3 employees.sql로 파일 열기
- 파일 열고 ".table" 입력하면 존재하는 테이블 모두 볼 수 있음

<br/>

### 1) Table 만들기
```
CREATE TABLE employees(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    salary INTEGER NOT NULL
);
```
#### cf) Column Types
- TEXT : string 저장
- NUMERIC : 숫자 일반
- INTEGER : 정수
- REAL : 실수
- BLOB (Binary Large Object)

#### cf) Constraints : column 만들 때 둘 수 있는 제약조건
- CHECK : 새로운 행 생성 시 특정 제약에 맞는 형식인지 확인함
- DEFAULT : 값이 없으면 디폴트 값 생성
- NOT NULL : 값이 있어야 함
- PRIMARY KEY : 데이터베이스에서 검색할 때 주요 key로 사용함
- UNIQUE : 이 column의 모든 row는 고유한 값만 가질 수 있음

<br/>

### 2) Table에 데이터 넣기
```
INSERT INTO employees(name, salary) VALUES ("Sue", 100);
```

<br/>

### 3) row 선택하기
- 모든 row 선택
```
SELECT * FROM employees
```
- 특정 column 선택
```
SELECT salary FROM employees
```
- 특정 row 선택
```
SELECT * FROM employees WHERE id = 2;
SELECT * FROM employees WHERE name = "Sue";
SELECT * FROM employees WHERE salary > 50;
SELECT * FROM employees WHERE salary > 50 AND name = "Sue";
SELECT * FROM employees WHERE salary IN ("100", "80");
```

#### cf) wildcard character %
- %는 0개 또는 1개 이상의 문자를 뜻함
- 하단 예시 : u가 들어간 모든 row를 선택
```
SELECT * FROM employees WHERE name LIKE "%u%";
```

#### cf) 터미널에서 보기 쉽게 나타내기
- ".mode columns"와 ".headers yes" 커맨드 사용하면 보기 쉽게 나옴

<br/>

### 4) function 사용하기
- function 예 : AVERAGE, COUNT, MAX, MIN, SUM
```
SELECT AVG(salary) FROM employees;
SELECT SUM(salary) FROM employees WHERE salary > 50;
```

<br/>

### 5) 이미 입력한 row 값 변경하기(update)
```
UPDATE employees
    SET salary =  2000
    WHERE name = "Sue";
```

<br/>

### 6) 이미 입력한 값 삭제하기
```
DELETE FROM employees WHERE name = "Sue";
```

<br/>

### 7) 기타 clause
- LIMIT, ORDER BY, GROUP BY, HAVING

<br/>

### 8) Table 연결하기
![sql1](https://eungang3.github.io/sue-is-programming/assets/sql1.jpg)
- 아이디만 있는 테이블을 association table이라고 함
- foreign key : 두 테이블을 연결하는 key. 다른 테이블의 primary key를 담고 있는 필드.
- JOIN : 두 테이블 연결해서 query 넣을 수 있게 해줌. Inner Join, Left Join, Right Join 등 
- Inner Join 예 : 테이블 간 매치 없는 row는 무시함

```
CREATE TABLE Assignment(
FOREIGN KEY (Employees_id) REFERENCES Employees (id)
FOREIGN KEY (Projects_id) REFERENCES Projects (id)
```

```
SELECT name, salary
FROM Employees JOIN Assignment
ON Assignment.Employees_id = Employees.id
```

<br/>

### 9) Indexing
- 자주 사용하는 테이블의 column에 인덱스 부여 -> 데이터베이스에서 데이터 빠르게 가져올 수 있음
- 인덱스 사용하면 테이블 업데이트하는 데 더 오랜 시간 걸림 -> 꼭 필요한 곳에만 사용
```
CREATE INDEX name_index ON employees (name);
```

<br/>

#### cf) SQL Vulnerabilities
- SQL Injection
 + 악성 유저가 인풋에 SQL 코드를 넣어서 사이트의 보안 장치를 무력화하는 것
 ```
 SELECT * FROM users
 WHERE username = username AND password = password;
 ```
 + username 인풋에 Sue" --라고 넣는 경우 : --" AND password = "12345"; 부분이 코멘트 처리됨 -> 비밀번호 없이도 Sue 계정에 접근할 수 있게 됨
 ```
 SELECT * FROM users
 WHERE username = "Sue"--" AND password = "12345";
 ```
 + 방지하기 : SQL에서 escape sequence 사용해서 인풋은 항상 plain text로만 인식하게 만들기, django 등 SQL을 다루는 프로그램에서 자체 escape sequence 사용하기 
 
 <br/>
 
- Race Conditions
 + 데이터베이스에 동시에 여러 개 query가 들어오는 경우를 말함
 + 동시에 들어오는 query를 막는 장치가 없는 경우 : 1000원 들어있는 은행계좌인데 웹에서 1000원 요청, 모바일에서 1000원 요청 -> 2000원 인출 가능해짐
 + 방지하기 : 한 query가 완료되기 전까지 다른 요청 못 들어오게 데이터베이스를 잠그기, query 실행중이라고 표시하기
 
 <br/>
 
## 2. Django Models
 - model : 데이터베이스의 스키마를 정의하는 Django 클래스.  
 - model 하나 = 데이터베이스의 table 하나 
 - 프로젝트 앱 내 models.py에 클래스 정의해서 생성 

#### cf1) Many to One relationship
 - A 테이블의 id는 B 테이블의 여러 id와 연결될 수 있지만, B 테이블의 id는 A 테이블의 한 id하고만 연결될 수 있는 경우
 - ForeignKey 필드 사용
  
<br/>

#### cf2) Many to Many relationship:
 - A 테이블의 id가 B 테이블의 여러 id와 연결될 수 있고, B 테이블의 id도 A 테이블의 여러 id와 연결될 수 있는 경우
 - ManyToManyField 사용

<br/>
 
## 3. Migration
- migration : Model을 바탕으로 SQL query를 생성하여 데이터베이스의 스키마를 업데이트하는 것. 
- 데이터베이스 스키마를 git처럼 버전 관리할 수 있음

<br/>

### 1) 모델 바탕으로 migration 만들기/수정하기 
- =SQL query 생성하기/수정하기
- 커맨드 ```python manage.py makemigrations``` 
- 첫 migration 시 앱 내 migration 디렉토리에 0001_initial.py 파일 생성. 

<br/>

### 2) migration 실행해서 데이터베이스에 적용하기 
- =데이터베이스에서 SQL query 실행하기
- 커맨드 ```python manage.py migrate```
- 데이터베이스 생성/수정 (=db.sqlite3 파일 생성/수정)
- 데이터베이스(db.sqlite3)에 model 바탕으로 스키마 생성/수정

<br/>

### 3) 데이터베이스에 데이터 입력하기
- Django Shell 들어가기 : 터미널에서 커맨드```python manage.py shell```

<br/>

#### cf) Django Admin
- 데이터 입력/수정을 할 수 있는 django에 내장된 인터페이스
- 어드민 유저 등록하기 : shell에서 ```python manage.py createsuperuser```
- admin.py에 정보 입력
{% highlight python %}
from django.contrib import admin
from .models import Flight.Airport

admin.site.register(Employees)
admin.site.register(Airport)
{% endhighlight %}
- 브라우저에서 사이트 url/admin 입력하면 접속 가능

<br/>

## 4. 예시 1 (Many to One relationship)
### 1) model 만들기
{% highlight python %}
 # 주문은 한 주문자만 갖지만, 한 주문자가 여러 주문을 시킬 수는 있음
 # models.py
 from django.db import models
 
 class Customer(models.Model):
    name = models.CharField(max_length = 64)
    membership = models.BooleanField(default=False)
    
    def __str__(self):
        return f"{self.name}, {self.membership}"
    
  class Order(models.Model):
    menu = models.CharField(max_length=64)
    # on_delete=models.CASCADE는 primary key를 가진 행이 삭제되면, 이 행도 같이 삭제하라는 뜻
    # related_name="ordered"는 한 primary key와 연결된 모든 행을 child table에서 검색할 때 사용 
    customer = models.ForeignKey(Writer, on_delete=models.CASCADE, related_name="ordered")
    
    def __str__(self):
        return f"{self.menu}, {self.customer}" 
{% endhighlight %}

### 2) migration 만들기 ```python manage.py makemigrations``` 

### 3) migrate 하기 ```python manage.py migrate```

### 4) 데이터 입력하기
{% highlight python %}
 # shell에서
 from projects.models import *

 c1 = Customer(name="Sue", membership="True")
 c2 = Customer(name="Bob", membership="False")
 c3 = Customer(name="Alice", membership="True")
 c1.save()
 c2.save()
 c3.save()
 
 o1 = Order(menu="Noodles", customer=c1)
 o2 = Order(menu="Pizza", customer=c1)
 o3 = Order(menu="Curry", customer=c2)
 o1.save()
 o2.save()
 o3.save()
{% endhighlight %}

### 5) 데이터 출력하기
{% highlight python %}
customers = Customer.objects.all()
customers
# 출력 : <QuerySet [<Customer: Sue, True>, <Customer: Bob, False>, <Customer: Alice, True>]>

first_customer = customers.first()
first_customer
# 출력 : <Customer: Sue, True>

first_customer.name
# 출력 : 'Sue'

Order.objects.all()
# 출력 : <QuerySet [<Order: Noodles, Sue, True>, <Order: Pizza, Sue, True>, <Order: Curry, Bob, False>]>

c1.ordered.all()
# related_name에 입력한 'ordered'로 child table(Order)검색
# 출력 : <QuerySet [<Order: Noodles, Sue, True>, <Order: Pizza, Sue, True>]>

{% endhighlight %}

<br/>

## 5. 예시 2 (Many to Many relationship)
### 1) model 만들기
{% highlight python %}
# 한 책을 여러 저자가 쓸 수도 있고, 한 저자가 여러 책을 쓸 수도 있음
# models.py

from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=64)
    price = models.IntegerField()
    
    def __str__(self):
        return f"{self.title}"
    
class Writer(models.Model):
    name = models.CharField(max_length=64)
    # blank=True는 books 필드는 빈 칸으로 두어도 된다는 뜻
    books = models.ManyToManyField(Book, blank=True, related_name="written_by")
    
    def __str__(self):
        return f"{self.name}, {self.title}"
{% endhighlight %}

### 2) migration 만들기 ```python manage.py makemigrations``` 

### 3) migrate 하기 ```python manage.py migrate```

### 4) 데이터 입력하기
{% highlight python %}
 # shell에서
 from projects.models import *
 
 b1 = Book(title="Encyclopedia", price=200)
 b2 = Book(title="Mystery of 2020", price=10)
 b3 = Book(title="Short stories", price=20)
 b1.save()
 b2.save()
 b3.save()
 
 w1 = Writer(name="Amy")
 w1.save()
 w1.books.add(b1, b2)
{% endhighlight %} 
 
### 5) 데이터 출력하기
{% highlight python %}
 w1
 # 출력 : <Writer: Amy, projects.Book.None>
 
 w1.books
 # 출력 : <django.db.models.fields.related_descriptors.create_forward_many_to_many_manager.<locals>.ManyRelatedManager object at 0x7fcd67aa17c0>
 # ManyToMany 필드는 오브젝트 리스트로 나옴. iterate하거나 .all() 사용해야 하나씩 볼 수 있음
 
 w1.books.all()
 # 출력 : <QuerySet [<Book: Encyclopedia, 200>, <Book: Mystery of 2020, 10>]>
 
 b1.written_by.all()
 # 출력 : <QuerySet [<Writer: Amy, projects.Book.None>, <Writer: Bob, projects.Book.None>]>
 
 Writer.objects.exclude(name="Bob")
 # Writer object 중 name 필드가 'Bob'인 것 제외하고 출력
 # 출력 : <QuerySet [<Writer: Amy, projects.Book.None>]>
{% endhighlight %}

<br/>

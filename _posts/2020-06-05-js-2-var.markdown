---
layout: post
title:  "Var, let, const 차이점 이해하기"
date:   2020-06-05 00:20:27 +0900
categories: Javascript
---

## 1. var
- ES5 버전에서 사용됨.
- function을 스코프로 가짐 (function 속 {} 내에서 var variable 정의했더라도, function 내라면 {} 안팎 상관없이 어디서나 접근 가능)
- hoisted : 정의 전 호출하면 undefined 값 가짐 (오류가 나진 않음)
- redeclaration : 가능 (보통 의도치 않은 상황인데 오류가 안나서 문제)
- reassignment : 가능

### cf) strict mode
- 의도치 않은 상황인데 오류가 안나서 문제인 경우가 있음.
- 이런 경우 오류 나게 해주는 모드.
- 예 : variation 정의하지 않은 경우(var first = 1이라야 하는데 first = 1로 쓴 경우 디폴트 모드에서는 global 스코프를 가지는 variable이 됨) strict mode에선 오류나게 해줌.
- ES5부터 도입 : 원하는 곳에 'strict mode'라고 써서 사용.
- ES6는 strict mode가 디폴트라 따로 설정할 필요 없음.

{% highlight javascript %}
//function을 스코프로 가짐
function run() {
  var first = "first";
  let second = "second";
  console.log(first, second);

  {
    var third = "third";
  }
  console.log(third);
}

run();
//first, second 프린트
//third 프린트
{% endhighlight %}

{% highlight javascript %}
//function안에서 정의하지 않았다면
//global 스코프 가짐

for (var i = 0; i < 5; i++) {
   console.log("Yay");
}

console.log(i); // 5 출력 (i가 global variable이라 접근 가능함)
{% endhighlight %}

{% highlight javascript %}
//hoisting 가능
console.log(run()); //undefined 출력

function run(){
 return true;
}
{% endhighlight %}

{% highlight javascript %}
//redeclaration 가능
var first = "first";
var first = "second";
console.log(first); //second 출력
{% endhighlight %}

<br/>

## 2. let
- ES6부터 등장.
- block{}을 스코프로 가짐.
- not hoisted: 정의하기 전 호출하면 ReferenceError 뜸.
- redeclaration : 불가능
- reassignment : 가능

{% highlight javascript %}
//block을 스코프로 가짐
function run() {
  var first = "first";
  let second = "second";
  console.log(first, second);

  {
    let third = "third";
  }
  console.log(third);
}

run();
//first, second 프린트
//referenceError
{% endhighlight %}

{% highlight javascript %}
for (let i = 0; i < 5; i++) {
   console.log("Yay");
}

console.log(i); // ReferenceError: i is not defined
// i가 block 스코프 갖는 variable이라 {} 밖에선 접근 못함
{% endhighlight %}

{% highlight javascript %}
//hoisting 가능
console.log(run()); //referenceError

function run(){
 return true;
}
{% endhighlight %}

{% highlight javascript %}
//redeclaration 불가능
let first = "first";
let first = "second";
console.log(first); //SyntaxError
{% endhighlight %}

<br/>

## 3. const
- ES6부터 등장.
- block{}을 스코프로 가짐.
- not hoisted: 정의하기 전 호출하면 ReferenceError 뜸.
- redeclaration : 불가능
- reassignment : 불가능
- const 사용하는 상수 variable은 주로 대문자로 작성

{% highlight javascript %}
//reassignment 불가능
const FIRST = "first";
FIRST = "second"; //Typerror
console.log(first);
{% endhighlight %}

{% highlight javascript %}
//array mutation은 가능
const A = [1, 2, 3, 4];
A[0] = 5; //가능
A = [2, 3, 4]; //Error
{% endhighlight %}

<br/>

### cf) Object.freeze
- Object mutation 방지하는 function
- 사용 후에는 해당 object에 add, update, delete 아무것도 안먹힘(에러 뜨진 않음)  

{% highlight javascript %}
let student = {
   name: "Owl",
   age: 300
};
Object.freeze(student);
obj.name = "Hummingbird"
console.log(student); // {name: "Owl", age: 300} 출력
{% endhighlight %}

<br/>

<br/><br/>
출처 : <br/>
<sup>1</sup>FreeCodeCamp.org. (n.d.). Retrieved June 05, 2020, from [https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/prevent-object-mutation](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/es6/prevent-object-mutation) 
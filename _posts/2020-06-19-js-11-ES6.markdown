---
layout: post
title:  "Javascript ES6의 새로운 기능 이해하기"
date:   2020-06-25 10:40:27 +0900
categories: Javascript
---

Udemy - [The Complete JavaScript Course 2020: Build Real Projects!](https://www.udemy.com/course/the-complete-javascript-course/) 강좌의 섹션 7. Next Generation Javascript: Intro to ES6 / ES2015를 요약한 내용입니다.

## 0. let / const

### 1) var
- ES5 버전에서 사용됨.
- function을 스코프로 가짐 (function 속 {} 내에서 var variable 정의했더라도, function 내라면 {} 안팎 상관없이 어디서나 접근 가능)
- 정의 전 호출 가능: hoist될 때 값이 undefined로 지정되기 때문에 호출하면 undefined 반환.
- redeclaration : 가능 (보통 의도치 않은 상황인데 오류가 안나서 문제)
- reassignment : 가능

### cf) strict mode
- 의도치 않은 상황인데 오류가 안나서 문제인 경우가 있음.
- 이런 경우 오류 나게 해주는 모드.
- 예 : variation 정의하지 않은 경우(var first = 1이라야 하는데 first = 1로 쓴 경우 디폴트 모드에서는 global 스코프를 가지는 variable이 됨) strict mode에선 오류나게 해줌.
- ES5부터 도입 : 원하는 곳에 'strict mode'라고 써서 사용.
- ES6는 strict mode가 디폴트라 따로 설정할 필요 없음.

{% highlight javascript %}
//function을 스코프로 가짐
function run() {
  var first = "first";
  let second = "second";
  console.log(first, second);

  {
    var third = "third";
  }
  console.log(third);
}

run();
//first, second 프린트
//third 프린트
{% endhighlight %}

{% highlight javascript %}
//function안에서 정의하지 않았다면
//global 스코프 가짐

for (var i = 0; i < 5; i++) {
   console.log("Yay");
}

console.log(i); // 5 출력 (i가 global variable이라 접근 가능함)
{% endhighlight %}

{% highlight javascript %}
//hoisting 가능
console.log(a); //undefined 출력

var a = 1;
{% endhighlight %}

{% highlight javascript %}
//redeclaration 가능
var first = "first";
var first = "second";
console.log(first); //second 출력
{% endhighlight %}

<br/>

### 2) let
- ES6부터 등장.
- block{}을 스코프로 가짐.
- 정의 전 호출 불가: hoist는 되지만 값 지정은 안 됨 -> 정의 전 호출하면 값 접근 불가 -> temporal dead zone(정의 전 사용할 수 없다는 뜻) 발생 -> ReferenceError 뜸
- redeclaration : 불가능
- reassignment : 가능

{% highlight javascript %}
//block을 스코프로 가짐
function run() {
  var first = "first";
  let second = "second";
  console.log(first, second);

  {
    let third = "third";
  }
  console.log(third);
}

run();
//first, second 프린트
//referenceError
{% endhighlight %}

{% highlight javascript %}
for (let i = 0; i < 5; i++) {
   console.log("Yay");
}

console.log(i); // ReferenceError: i is not defined
// i가 block 스코프 갖는 variable이라 {} 밖에선 접근 못함
{% endhighlight %}

{% highlight javascript %}
// 정의 전 접근 불가
console.log(a); //referenceError

let a = 1;
{% endhighlight %}

{% highlight javascript %}
//redeclaration 불가능
let first = "first";
let first = "second";
console.log(first); //SyntaxError
{% endhighlight %}

<br/>

### 3) const
- ES6부터 등장.
- block{}을 스코프로 가짐.
- 정의 전 호출 불가: hoist는 되지만 값 지정은 안 됨 -> 정의 전 호출하면 값 접근 불가 -> temporal dead zone(정의 전 사용할 수 없다는 뜻) 발생 -> ReferenceError 뜸
- redeclaration : 불가능
- reassignment : 불가능
- const 사용하는 상수 variable은 주로 대문자로 작성

{% highlight javascript %}
//reassignment 불가능
const FIRST = "first";
FIRST = "second"; //Typerror
console.log(FIRST);
{% endhighlight %}

{% highlight javascript %}
//array mutation은 가능
const A = [1, 2, 3, 4];
A[0] = 5; //가능
A = [2, 3, 4]; //Error
{% endhighlight %}

<br/>

### cf) Object.freeze
- Object mutation 방지하는 function
- 사용 후에는 해당 object에 add, update, delete 아무것도 안먹힘(에러 뜨진 않음)  

{% highlight javascript %}
let student = {
   name: "Owl",
   age: 300
};
Object.freeze(student);
obj.name = "Hummingbird"
console.log(student); // {name: "Owl", age: 300} 출력
{% endhighlight %}

<br/>

### cf) {}로 IIFE 대신하기
- let, const는 블록 스코프 갖기 때문에 {} 안에만 넣으면 data privacy 지킬 수 있음
- data privacy만 위해서라면 {}와 let, const 만으로 IIFE 대체 가능 
{% highlight javascript %}
{
    const test = 1;
    let test1 = 2;
}

console.log(test, test1); // ReferenceError 
{% endhighlight %}

<br/>

## 1. String 다루기
### 1) template literals
- string 연결할 때 + 사용하는 방법 대체 가능
- 읽기 쉽고 사용하기 쉬움
{% highlight javascript %}
a = 'cat';
console.log(`This is a ${cat}.`);
{% endhighlight %}

<br/>

### 2) string methods
- startsWith() : string이 () 안에 있는 글자로 시작하는지 체크해서 true/false 반환
- endsWith() : string이 () 안에 있는 글자로 끝나는지 체크해서 true/false 반환
- includes() : string에 () 안에 있는 글자가 있는지 체크해서 true/false 반환
- repeat() : ()안에 입력한 횟수만큼 string 반복

{% highlight javascript %}
const a = 'apple';
console.log(a.startsWith('a')) // true
console.log(a.repeat(2)) // appleapple
{% endhighlight %}

<br/>

## 2. Arrow function
- 새로운 function syntax 
{% highlight javascript %}
const numbers = [1, 2, 3];

// parameter가 하나일 때 () 생략가능
// body 내용이 한 줄일 때 {}, return 키워드 생략가능
let added = numbers.map(el => el + 1);
console.log(added); // [2, 3, 4]

// parameter가 하나 이상일 때 () 명시
// body 내용이 한 줄 이상일 때 {}, return 키워드 명시
let showIndex = numbers.map((el, index) => {
    let multiplied = el * 2;
    return `Element ${index} is ${multiplied}`;
})

console.log(showIndex);
// ["Element 0 is 2", "Element 1 is 4", "Element 2 is 6"]
{% endhighlight %}

- lexical this keyword: 고유한 this 값 갖지 않음, arrow function이 정의된 EC의 this 값을 가짐.
{% highlight javascript %}
// ES5
var dog5 = {
    name: 'Snoopy',
    introduce: function(){
        document.querySelector('.box').addEventListener('click', function(){
            console.log('My name is ' + this.name);
        })
    }
}
dog5.introduce();
// My name is undefined 출력
// introduce는 regular function이라서 this = window object

var dog55 = {
    name: 'Snoopy',
    introduce: function(){
        var self = this;
        document.querySelector('.box').addEventListener('click', function(){
            console.log('My name is ' + self.name);
        })
    }
}
dog55.introduce();
// My name is Snoopy 출력

const dog555 = {
    name: 'Snoopy',
    introduce: function(word){
        function sayName(){
            console.log(this.name);
        }
        var newFunc = sayName.bind(this);
        newFunc("!")
    }
}

dog555.introduce();
//Snoopy 출력
// bind method로 sayName 복사하고 this값 수동으로 지정
{% endhighlight %}

{% highlight javascript %}
// ES6
const dog6 = {
    name: 'Snoopy',
    introduce: function(){
        var sayName = () => {
            console.log(this);
        }
        sayName();
    }
}
dog6.introduce();
// dog6 object 출력
// sayName의 this 값은 introduce function의 this 값, 즉 dog6 object.

const dog66 = {
    name: 'Snoopy',
    introduce: () => {
        console.log(this);
        }
    }

dog66.introduce();
// window object 출력
// introduce function의 this 값은 dog66의 this 값, 즉 window object. 
{% endhighlight %}

{% highlight javascript %}
// ES6, anonymous callback function으로 사용하는 경우
function Dog(name) {
    this.name = name;
}

Dog.prototype.woof = function(words){
    let arr = words.map(el => `${el}! ${this.name}`);
    console.log(arr);
}

var greetings = ['Hi', 'Hello'];
new Dog('snoopy').woof(greetings);

// ["Hi! snoopy", "Hello! snoopy"]
// arrow function의 this는 arrow function이 정의된 
// woof method의 this값을 가짐 
{% endhighlight %}

<br/>

## 3. Destructing (구조 분해 할당)
- array나 object같은 구조 속에 있는 값을 꺼내서 각각 변수로 만드는 것
- function에서 값 여러 개 반환할 때 특히 유용함.

{% highlight javascript %}
// array인 경우

const [name, color] = ['Garfield', 'orange'];
console.log(name); // Garfield
console.log(color); // orange
{% endhighlight %}

{% highlight javascript %}
// object인 경우

const garfield = {
    name: 'garfield',
    color: 'orange'
}

const {name, color} = garfield;
console.log(name) // garfield
console.log(color) // orange

const {name: a, color: b} = garfield;
console.log(a) // garfield
console.log(b) // orange
{% endhighlight %}

{% highlight javascript %}
// 값 여러 개 반환하는 function에 사용하기

function calc(num) {
    return [num + 2, num * 2]
}

const [added, multiplied] = calc(1);
console.log(added) // 3
console.log(multiplied) // 2
{% endhighlight %}

<br/>

## 4. Array 
### 1) from() method
- 리스트를 array로 바꿔줌

{% highlight javascript %}
//ES5 

var container = document.querySelectorAll('.container');
var containerArr = Array.prototype.slice.call(container);
containerArr.forEach(function(cur){
    cur.style.color = 'blue';
})
{% endhighlight %}

{% highlight javascript %}
//ES6 

var container = document.querySelectorAll('.container');
var containerArr = Array.from(container);
containerArr.forEach(function(cur){
    cur.style.color = 'blue';
})

/* 더 줄일수도 있음
Array.from(container).forEach(function(cur){
    cur.style.color = 'blue';
})
*/
{% endhighlight %}

<br/>

### 2) for of loop
- array에 사용하는 loop
- forEach(), map()과 달리 break, continue 사용 가능
{% highlight javascript %}
const testArr = [1, 2, 3, 4, 5];
for (const cur of testArr) {
    if (cur === 3) {
        break;
    }
    console.log(cur) 
}

// 1, 2
{% endhighlight %}

{% highlight javascript %}
//DOM의 className property로 html 요소의 클래스명 가져옴
for (const cur of containers) {
    if (cur.className.includes('orange')){
        continue;
    }
    cur.textContent = 'orange!!!';
}
{% endhighlight %}

<br/>

### 3) findIndex() / find()
- 조건에 맞는 array index / element 찾아주는 method
- ()안에 callback function 넣음. 파라미터 지정하면 순서대로 currentValue, index, array를 인자로 넣음 
{% highlight javascript %}
// ES5

var numbers = [1, 2, 3, 4];
var overThree = numbers.map(function(cur){
    return cur > 3;
})
console.log(overThree); // [false, false, false, true]
console.log(overThree.indexOf(true)); // 3
console.log(numbers[overThree.indexOf(true)]) // 4
{% endhighlight %}

{% highlight javascript %}
// ES6

var numbers = [1, 2, 3, 4];
console.log(numbers.findIndex(cur => cur > 3));
console.log(numbers.find(cur => cur > 3));
{% endhighlight %}

<br/>

## 5. Spread operator(스프레드 연산자)
- array나 node list 안에 든 것을 꺼내줌
- 꺼낼 것 앞에 ... 붙임
{% highlight javascript %}
// ES5
var numbers = [1, 2, 3, 4];
var sum = function(a, b, c, d){
    return a + b + c + d;
}

// apply method가 특정 this 가리킬 필요 없으면 null 사용
var sum2 = sum.apply(null, numbers);
console.log(sum2) // 10
{% endhighlight %}

{% highlight javascript %}
// 함수에 array를 인자로 넣기

const numbers = [1, 2, 3, 4];
const sum = function(a, b, c, d){
    return a + b + c + d;
}

console.log(sum(...numbers)) // 10
{% endhighlight %}

{% highlight javascript %}
// 두 array 합치기
const numbers1 = [1, 2];
const numbers2 = [3, 4];
const numbers3 = [...numbers1, 100, ...numbers2];
console.log(numbers3) // [1, 2, 100, 3, 4]
{% endhighlight %}

{% highlight javascript %}
// node list에 사용하기
const a = document.querySelector('a');
const container = querySelectorAll('.container');

// 한 리스트로 합침
const together = [a, ...container]; 

// array로 변경하고 array method인 forEach사용
Array.from(together).forEach(cur => cur.style.color = 'red');
{% endhighlight %}

<br/>

## 6. Rest parameter
- 함수 인자의 갯수를 미리 정해두지 않는 파라미터
- spread operator와 반대로 각각의 값을 array로 만들어줌.
- cf) arguments object: FEC 생성할 때 만들어지는 object. 함수에 들어온 모든 인자를 담아둠. array처럼 생겼지만 aray는 아님
{% highlight javascript %}
// ES5

function greet(name) {
    // arguments object를 array로 변환 (name 파라미터 제외)
    var argsArr = Array.prototype.slice.call(arguments, 1);
    argsArr.forEach(function(cur){
        console.log(cur + ' ' + name)
    })
}

greet('hi', 'hello');
{% endhighlight %}

{% highlight javascript %}
function greet(name, ...greeting) {
    greeting.forEach(cur => console.log(cur + ' ' + name));
}

greet('hi', 'hello');
{% endhighlight %}

<br/>

## 7. Default parameter
- 디폴트로 들어가는 인자를 설정해주는 파라미터
{% highlight javascript %}
// ES5
function Dog(name, personality) {
    // 파라미터에는 있는데 인자로 들어오지 않으면 값 undefined로 지정됨
    personality === undefined ? personality = 'friendly' : personality = personality

    this.name = name;
    this.personality = personality;
}

var snoopy = new Dog('snoopy');
console.log(snoopy.personality) // friendly

{% endhighlight %}

{% highlight javascript %}
// ES6

function Dog(name, personality = 'friendly') {
    this.name = name;
    this.personality = personality;
}

var snoopy = new Dog('snoopy');
console.log(snoopy.personality) // friendly

var cheddar = new Dog('cheddar', 'smart')
console.log(cheddar.personality) // smart
{% endhighlight %}

<br/>

## 8. Maps
- ES6부터 등장한 key-value data structure
- object(=hash map)에서는 string만 key로 사용 가능, iterator method 사용 불가
- maps에서는 primitive type, function, object도 key로 사용 가능, iteratior method 사용 가능, 데이터 추가/삭제가 object보다 쉬움

{% highlight javascript %}
const quizz = new Map();
quizz.set('question', 'what is the best?');
quizz.set(1, 'sleep');
quizz.set(2, 'cake');
quizz.set(3, 'rock')
quizz.set('correct', 1);
quizz.set(true, 'Right!');
quizz.set(false, 'Wrong');

// value 출력 
console.log(quizz.get(1)); // sleep

// key-value 갯수 출력 (object에선 안됨)
console.log(quizz.size) // 6

// 특정 key-value 삭제하기 
quizz.delete(3)

// 모든 key-value 삭제하기 
// quizz.clear()

// key-value 있는지 확인
console.log(quizz.has(3)) // false

// map method - forEach
quizz.forEach((value, key) => console.log(key + ': ' + value))

// for of loop
for (let keyValue of quizz) {
    console.log(keyValue); // 1, sleep
} 

// for of loop에 destructing 사용해서 key, value 각각 사용하기
//entries()는 key-value pair로 이루어진 iterator object 반환
for (let [key, value] of quizz.entries()) {
    console.log(key); // 1
} 

// typeof 사용해서 key가 숫자인 value만 프린트
for (let [key, value] of quizz.entries()){
    if (typeof(key) === 'number'){
        console.log(value);
    }
}

// boolean 값으로 된 key 활용하기
const answer = 1;
console.log(quizz.get(answer === quizz.get('answer'))); // wrong 출력
{% endhighlight %}

<br/>

## 9. Class
- syntactic sugar. 문법상 간결해진 것이나 기능 상 달라진 건 없음
- function constructor는 hoisted, class는 not hoisted
- class에선 method만 inherit시킬 수 있음. (property는 안 됨)
- cf) static method : class instance가 inherit 하지 않는 class에 정의된 method 

{% highlight javascript %}
// ES5

function Dog(name, age){
    this.name = name;
    this.age = age;
}

Dog.prototype.sayName = function(){
    console.log(this.name);
}

var snoopy = new Dog('snoopy', 3);
{% endhighlight %}

{% highlight javascript %}
// ES6

class Dog {
    constructor (name, age) {
        this.name = name,
        this.age = age
    }

    // Dog prototype
    sayName() {
        console.log(this.name);
    }

    // static method 
    static woof() {
        console.log('woof');
    }
}

const snoopy = new Dog('snoopy', 3)
Dog.woof(); // woof
{% endhighlight %}

- super class : inherit 하는 class
- subclass : inherit 되는 class

{% highlight javascript %}
// ES5

function Animal(name, age){
    this.name = name;
    this.age = age;
}

Animal.prototype.sayName = function(){
    console.log(this.name);
}

function Dog(name, age, personality) {
    Animal.call(this, name, age);
    this.personality = personality;
}

Dog.prototype = Object.create(Animal.prototype);

Dog.prototype.woof = function() {
    console.log('woof');
}

var snoopy = new Dog('snoopy', 3, 'friendly');
{% endhighlight %}

{% highlight javascript %}
// ES6

class Animal {
    constructor (name, age) {
        this.name = name,
        this.age = age
    }

    // Animal prototype
    sayName() {
        console.log(this.name);
    }

}

class Dog extends Animal {
    constructor(name, age, personality) {
        super(name, age);
        this.personality = personality;
    }

    woof() {
        console.log('woof');
    }
}

const snoopy = new Dog('snoopy', 3, 'friendly');
{% endhighlight %}